# -*- coding: utf-8 -*-
"""Proyecto_Final_Eduardo_Fernandeze .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_qpATIIr568GKmkKVZxql2WoMbjoXgEs

[Librerias](https://colab.research.google.com/drive/1_qpATIIr568GKmkKVZxql2WoMbjoXgEs#scrollTo=qebfM-8v1Ynu)

[Data Set](https://colab.research.google.com/drive/1_qpATIIr568GKmkKVZxql2WoMbjoXgEs#scrollTo=qebfM-8v1Ynu)

[Feature Engineering ](https://colab.research.google.com/drive/1_qpATIIr568GKmkKVZxql2WoMbjoXgEs#scrollTo=r7iWqRLL0uv2)

[Vizualición de Tablas](https://colab.research.google.com/drive/1_qpATIIr568GKmkKVZxql2WoMbjoXgEs#scrollTo=-ZVDAU2T04HX)

[Correlación](https://colab.research.google.com/drive/1_qpATIIr568GKmkKVZxql2WoMbjoXgEs#scrollTo=SUu7Oy7m1EnL)

[Modelo de Machine Learning](https://colab.research.google.com/drive/1_qpATIIr568GKmkKVZxql2WoMbjoXgEs#scrollTo=KWwhIsjX1Jxr)

# LIBRERIAS
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

#para montar en drive
from google.colab import drive
drive.mount('/content/gdrive')
from sklearn.tree import DecisionTreeClassifier  #arbol de decision
from sklearn import tree #arbol de decision

from sklearn.model_selection import train_test_split
from sklearn import metrics 

from sklearn.linear_model import LinearRegression

from sklearn.linear_model import LogisticRegression #regresion logistica

from sklearn.cluster import KMeans

"""# DATA SET

El objetivo de este proyecto es realizar un analisis del dataset " Covid Data" con el fin de establecer los riesgos de muerte basados en datos historicos relacionados a diferentes tipos de enfermedades.
Utilizaremos gráficos de la librería de Python para analizar de manera visual las variables elegidas e intentar responder los cuestionamientos sobre la información que contiene nuestro dataset. Como, por ejemplo:

¿que edad tiene mayor riesgo de muerte?
¿qué enfermadades son las de mayor riesgo al contraer covid?
¿qué conjunto de enfermedades pudieran causar muerte al contraer covid?

# hipotesis:Los riesgos para personas mayores, con enfermedades respiratorias son mas susceptibles a sufrir complicaciones al contar con Covid
"""

covid = pd.read_csv('/content/gdrive/MyDrive/coderhouse/Covid Data.csv')
covid

"""Analisis de numeros nulos en columnas"""

covid.isna().sum()

covid.dtypes

"""Para poder tener una interpretación de los datos mas accesible y entendible, realizamos la conversion de los datos reemplanzandolos

In the Boolean features, 1 means "yes" and 2 means "no". values as 97 and 99 are missing data.
sex: 1 for female and 2 for male.

* age: of the patient.
* classification: covid test findings. Values 1-3 mean that the patient was diagnosed with covid in different
degrees. 4 or higher means that the patient is not a carrier of covid or that the test is inconclusive.
* patient type: type of care the patient received in the unit. 1 for returned home and 2 for hospitalization.
* pneumonia: whether the patient already have air sacs inflammation or not.
* pregnancy: whether the patient is pregnant or not.
* diabetes: whether the patient has diabetes or not.
* copd: Indicates whether the patient has Chronic obstructive pulmonary disease or not.
* asthma: whether the patient has asthma or not.
* inmsupr: whether the patient is immunosuppressed or not.
* hypertension: whether the patient has hypertension or not.
* cardiovascular: whether the patient has heart or blood vessels related disease.
* renal chronic: whether the patient has chronic renal disease or not.
* other disease: whether the patient has other disease or not.
* obesity: whether the patient is obese or not.
* tobacco: whether the patient is a tobacco user.
* usmr: Indicates whether the patient treated medical units of the first, second or third level.
* medical unit: type of institution of the National Health System that provided the care.
* intubed: whether the patient was connected to the ventilator.
* icu: Indicates whether the patient had been admitted to an Intensive Care Unit.
* date died: If the patient died indicate the date of death, and 9999-99-99 otherwise.

# FEATURE ENGINEERING

Creación de una nueva columna "deaths" en la cual refleje si la persona fallecio o vive
"""

covid["deaths"] = [0 if each=="9999-99-99" else 1 for each in covid.DATE_DIED]

"""Reemplazo de datos para tener variables booleanas"""

covid['INTUBED'] = covid['INTUBED'].replace(97,0)
covid['INTUBED'] = covid['INTUBED'].replace([2,99],1)
covid['PNEUMONIA'] = covid['PNEUMONIA'].replace(2,0)
covid['PNEUMONIA'] = covid['PNEUMONIA'].replace(99,1)
covid['PREGNANT'] = covid['PREGNANT'].replace(97,0)
covid['PREGNANT'] = covid['PREGNANT'].replace([2,98],1)
covid['DIABETES'] = covid['DIABETES'].replace(2,0)
covid['DIABETES'] = covid['DIABETES'].replace(98,1)
covid['COPD'] = covid['COPD'].replace(2,0)
covid['COPD'] = covid['COPD'].replace(98,1)
covid['ASTHMA'] = covid['ASTHMA'].replace(2,0)
covid['ASTHMA'] = covid['ASTHMA'].replace(98,1)
covid['INMSUPR'] = covid['INMSUPR'].replace(2,0)
covid['INMSUPR'] = covid['INMSUPR'].replace(98,1)
covid['HIPERTENSION'] = covid['HIPERTENSION'].replace(2,0)
covid['HIPERTENSION'] = covid['HIPERTENSION'].replace(98,1)
covid['OTHER_DISEASE'] = covid['OTHER_DISEASE'].replace(2,0)
covid['OTHER_DISEASE'] = covid['OTHER_DISEASE'].replace(98,1)
covid['CARDIOVASCULAR'] = covid['CARDIOVASCULAR'].replace(2,0)
covid['CARDIOVASCULAR'] = covid['CARDIOVASCULAR'].replace(98,1)
covid['OBESITY'] = covid['OBESITY'].replace(2,0)
covid['OBESITY'] = covid['OBESITY'].replace(98,1)
covid['TOBACCO'] = covid['TOBACCO'].replace(2,0)
covid['TOBACCO'] = covid['TOBACCO'].replace(98,1)
covid['ICU'] = covid['ICU'].replace(97,0)
covid['ICU'] = covid['ICU'].replace([2,99],1)
covid['RENAL_CHRONIC'] = covid['RENAL_CHRONIC'].replace(2,0)
covid['RENAL_CHRONIC'] = covid['RENAL_CHRONIC'].replace(98,1)

covid.head()

covid.describe()

"""# VISUALIZACIÓN TABLAS

Para obtener una mejor Visualización de enfermedades con la relación a muertes utilizamos las siguientes tablas en las cuales ya con los datos transormados podemos ver las enfermedades que se ven mas afectadas por el covid, ya que ademas hacemos la division de datos basado en muertes o sobrevivientes
"""

fig = plt.figure(figsize=(15,25))
fig.subplots_adjust(hspace=.5, wspace=.5)
ax = fig.add_subplot(5,3,1)
sns.histplot(data=covid, 
             x="INTUBED", 
             hue="deaths",
             multiple="stack"
             )
ax = fig.add_subplot(5,3,2)
sns.histplot(data=covid, 
             x="PNEUMONIA", 
             hue="deaths",
             multiple="stack"
             )
ax = fig.add_subplot(5,3,3)
sns.histplot(data=covid, 
             x="PREGNANT", 
             hue="deaths",
             multiple="stack"
             )
ax = fig.add_subplot(5,3,4)
sns.histplot(data=covid, 
             x="DIABETES", 
             hue="deaths",
             multiple="stack"
             )
ax = fig.add_subplot(5,3,5)
sns.histplot(data=covid, 
             x="COPD", 
             hue="deaths",
             multiple="stack"
             )
ax = fig.add_subplot(5,3,6)
sns.histplot(data=covid, 
             x="ASTHMA", 
             hue="deaths",
             multiple="stack"
             )
ax = fig.add_subplot(5,3,7)
sns.histplot(data=covid, 
             x="INMSUPR", 
             hue="deaths",
             multiple="stack"
             )
ax = fig.add_subplot(5,3,8)
sns.histplot(data=covid, 
             x="CARDIOVASCULAR", 
             hue="deaths",
             multiple="stack"
             )
ax = fig.add_subplot(5,3,9)
sns.histplot(data=covid, 
             x="OBESITY", 
             hue="deaths",
             multiple="stack"
             )
ax = fig.add_subplot(5,3,10)
sns.histplot(data=covid, 
             x="RENAL_CHRONIC", 
             hue="deaths",
             multiple="stack"
             )
ax = fig.add_subplot(5,3,11)
sns.histplot(data=covid, 
             x="TOBACCO", 
             hue="deaths",
             multiple="stack"
             )

"""En el siguiente grafico realizamos una grafica la cual nos ayuda a ver la cantidad de contagias dependiendo de la edad de las personas, en el cual nos podemos dar cuenta que las personas entre 20 a 50 años fueron las que tuvieron mayor cantidad de contagios, sin embargo gran porcentaje se recupero, no podemos decir lo mismo para las personas entre un rango de 60 a 100, en los cuales lamentablemente gran porcentaje de las personas pierden la vida"""

fig = plt.figure(figsize=(50,50))
fig.subplots_adjust(hspace=.5, wspace=.5)
ax = fig.add_subplot(5,3,1)
sns.histplot(data=covid, 
             x="AGE",
             hue="deaths" 
             )

sns.histplot(data=covid, x="AGE", hue="deaths"
            ,multiple='stack'
            )

ax = sns.countplot(covid['deaths']);

sns.histplot(data=covid, x="MEDICAL_UNIT", hue="deaths"
            ,multiple='stack'
            )

"""# CORRELACIÓN

En la siguiente tabla utilizaremos un analisis de correlación de Pearson, el cual nos ayudara a analizar cuales variables se encuentran fuertemente relacionadas entre ellas, podemos observar por ejemplo la fuerte correlación entre muertes y tipo de paciente, si se encontraba intubado, contaba con enfermedad de pneumonia, asi como la edad.
"""

corr_df = covid.corr(method='pearson') 
 
plt.figure(figsize=(18, 16))
 
sns.heatmap(corr_df,annot=True)
plt.show()

"""Eliminación y division de columnas para entrenamiento, escogemos en "y" la columna de interes que son "muertes o deaths"
"""

X = covid.drop(['deaths','DATE_DIED'],axis= 1)

y = covid['deaths']

X.head()

X = pd.get_dummies(data=X, drop_first=True)
X.head()

y.head()

"""# ENTRENAMIENTO ML Regresion Logistica

Entrenamiento con un 75% de Entrenamiento y 25% de Prueba
"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=15)

y_train

logreg = LogisticRegression(max_iter=1000)

logreg.fit(X_train, y_train)

y_pred = logreg.predict(X_test)

print("Accuracy:",metrics.accuracy_score(y_test, y_pred))

from sklearn.metrics import confusion_matrix, classification_report

print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

"""Conclusiones:
El modelo de Regresion Logistico muestra un accuracy del 0.937 lo cual nos da un muy buen valor para validar el dataset

Entrenamiento ML Decision Three
"""

import pandas as pd
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, classification_report

model = DecisionTreeClassifier(random_state=435,
                             max_depth=5)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

fig = plt.figure(figsize=(18,10))
tree.plot_tree(model,
               feature_names=X_train.columns,  
               class_names=True,
               fontsize=12,
               proportion=True,
               filled=True
               )

plt.show()

print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

print("Accuracy:",metrics.accuracy_score(y_test, y_pred))

"""Eleccion de Modelo de ML, aun y cuando comparten un Acurracy muy cercano entre las dos, el modelo de regresion logistica muestra mejores resultados.

PCA
"""

from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn import metrics
from sklearn.metrics import accuracy_score

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=15)

sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

X_train[0:10]

pca = PCA()
X_train_1 = pca.fit_transform(X_train)
X_test_1 = pca.transform(X_test)

explained_variance = pca.explained_variance_ratio_
explained_variance

PC_components = np.arange(pca.n_components_) + 1

figure = sns.set(style='whitegrid', font_scale=1.2)
fig, ax = plt.subplots(figsize=(10, 7))
figure = sns.barplot(x=PC_components, y=pca.explained_variance_ratio_, color='b')
figure = sns.lineplot(x=PC_components-1, y=np.cumsum(pca.explained_variance_ratio_), color='black', linestyle='-', linewidth=2, marker='o', markersize=8)

plt.title('Scree Plot')
plt.xlabel('N-th Principal Component')
plt.ylabel('Variance Explained')
plt.ylim(0, 1)
plt.show()

pca = PCA(n_components=1)  
X_train = pca.fit_transform(X_train)
X_test = pca.transform(X_test)

PCAlogreg = LogisticRegression(max_iter=1000)
PCAlogreg .fit(X_train, y_train)

# Predicción
y_pred = PCAlogreg .predict(X_test)

accuracy = accuracy_score(y_test, y_pred)
print('El accuracy del modelo es:', accuracy)

fig, ax = plt.subplots(figsize=(10,10))

cm = metrics.confusion_matrix(y_test, y_pred, labels=PCAlogreg.classes_)
disp = metrics.ConfusionMatrixDisplay(confusion_matrix=cm,
                              display_labels=PCAlogreg.classes_)
disp.plot(ax=ax,cmap=plt.cm.Blues)
plt.show()

"""![image.png](data:image/png;base64,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)

viendo con la comparación inicial sin uso del PCA, vemos como disminuye el accuracy por muy poco %, sin embargo se buscaria tener el mayor valor posible

# Cross Validation

Se agregan librerias de Sklearn para regresion logistica, asi como el modelo de Cross Validate
"""

import pandas as pd
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import cross_validate
from sklearn.model_selection import StratifiedKFold

"""colocamos el codigo para crear el cross validation con 5 dobleces y obtener los valores de cada dobles"""

kf = StratifiedKFold(n_splits=5, #dividir en 5 secciones
                     shuffle=True, 
                     random_state=42)

cnt = 1
# split()  method generate indices to split data into training and test set.
for train_index, test_index in kf.split(X, y):
    print(f'Fold:{cnt}, Train set: {len(train_index)}, Test set:{len(test_index)}')
    cnt+=1

scores = cross_validate(logreg, X, y, scoring='accuracy', cv=5)
print(scores['test_score'])

"""Creamos la variable para guardar el dato"""

avg_scores = scores['test_score']

"""Creamos el promedio de los valores obtenidos y obtenemos el valor final"""

print(f'Average score: {"{:.2f}".format(avg_scores.mean())}')

"""El modelo arroja un 0.91 de accuracy, comparandolo con el modelo anterior que obtuvimos un 0.9371
El modelo se ve afectado principalmente por el Fold 1 y 3, ya que en estas particiones podemos identificar que su Acurracy es mas bajo, comparado con los otros 3 Folds
"""

